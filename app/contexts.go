// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "Modoki API": Application Contexts
//
// Command:
// $ goagen
// --design=github.com/modoki-paas/modoki/design
// --out=$(GOPATH)/src/github.com/modoki-paas/modoki
// --version=v1.3.1

package app

import (
	"context"
	"github.com/goadesign/goa"
	"net/http"
	"strconv"
	"time"
	"unicode/utf8"
)

// CreateContainerContext provides the container create action context.
type CreateContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Command     []string
	Entrypoint  []string
	Env         []string
	Image       string
	Name        string
	SslRedirect bool
	Volumes     []string
	WorkingDir  *string
}

// NewCreateContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller create action.
func NewCreateContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramCommand := req.Params["command"]
	if len(paramCommand) > 0 {
		params := paramCommand
		rctx.Command = params
	}
	paramEntrypoint := req.Params["entrypoint"]
	if len(paramEntrypoint) > 0 {
		params := paramEntrypoint
		rctx.Entrypoint = params
	}
	paramEnv := req.Params["env"]
	if len(paramEnv) > 0 {
		params := paramEnv
		rctx.Env = params
	}
	paramImage := req.Params["image"]
	if len(paramImage) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("image"))
	} else {
		rawImage := paramImage[0]
		rctx.Image = rawImage
	}
	paramName := req.Params["name"]
	if len(paramName) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("name"))
	} else {
		rawName := paramName[0]
		rctx.Name = rawName
		if ok := goa.ValidatePattern(`^[a-zA-Z0-9_]+$`, rctx.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`name`, rctx.Name, `^[a-zA-Z0-9_]+$`))
		}
		if utf8.RuneCountInString(rctx.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`name`, rctx.Name, utf8.RuneCountInString(rctx.Name), 1, true))
		}
		if utf8.RuneCountInString(rctx.Name) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`name`, rctx.Name, utf8.RuneCountInString(rctx.Name), 64, false))
		}
	}
	paramSslRedirect := req.Params["sslRedirect"]
	if len(paramSslRedirect) == 0 {
		rctx.SslRedirect = true
	} else {
		rawSslRedirect := paramSslRedirect[0]
		if sslRedirect, err2 := strconv.ParseBool(rawSslRedirect); err2 == nil {
			rctx.SslRedirect = sslRedirect
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("sslRedirect", rawSslRedirect, "boolean"))
		}
	}
	paramVolumes := req.Params["volumes"]
	if len(paramVolumes) > 0 {
		params := paramVolumes
		rctx.Volumes = params
	}
	paramWorkingDir := req.Params["workingDir"]
	if len(paramWorkingDir) > 0 {
		rawWorkingDir := paramWorkingDir[0]
		rctx.WorkingDir = &rawWorkingDir
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *CreateContainerContext) OK(r *GoaContainerCreateResults) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "vnd.application/goa.container.create.results+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateContainerContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Conflict sends a HTTP response with status code 409.
func (ctx *CreateContainerContext) Conflict(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 409, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *CreateContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// DownloadContainerContext provides the container download action context.
type DownloadContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID           string
	InternalPath string
}

// NewDownloadContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller download action.
func NewDownloadContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*DownloadContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DownloadContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	paramInternalPath := req.Params["internalPath"]
	if len(paramInternalPath) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("internalPath"))
	} else {
		rawInternalPath := paramInternalPath[0]
		rctx.InternalPath = rawInternalPath
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DownloadContainerContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/octet-stream")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DownloadContainerContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *DownloadContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ExecContainerContext provides the container exec action context.
type ExecContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Command []string
	ID      string
	Tty     *bool
}

// NewExecContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller exec action.
func NewExecContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*ExecContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ExecContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramCommand := req.Params["command"]
	if len(paramCommand) > 0 {
		params := paramCommand
		rctx.Command = params
	}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	paramTty := req.Params["tty"]
	if len(paramTty) > 0 {
		rawTty := paramTty[0]
		if tty, err2 := strconv.ParseBool(rawTty); err2 == nil {
			tmp2 := &tty
			rctx.Tty = tmp2
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("tty", rawTty, "boolean"))
		}
	}
	return &rctx, err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ExecContainerContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ExecContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetConfigContainerContext provides the container getConfig action context.
type GetConfigContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewGetConfigContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller getConfig action.
func NewGetConfigContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetConfigContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetConfigContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetConfigContainerContext) OK(r *GoaContainerConfig) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "vpn.application/goa.container.config+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetConfigContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetConfigContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// InspectContainerContext provides the container inspect action context.
type InspectContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewInspectContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller inspect action.
func NewInspectContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*InspectContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := InspectContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *InspectContainerContext) OK(r *GoaContainerInspect) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "vpn.application/goa.container.inspect+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *InspectContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *InspectContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ListContainerContext provides the container list action context.
type ListContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewListContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller list action.
func NewListContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListContainerContext) OK(r GoaContainerListEachCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "vpn.application/goa.container.list.each+json; type=collection")
	}
	if r == nil {
		r = GoaContainerListEachCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ListContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// LogsContainerContext provides the container logs action context.
type LogsContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Follow     bool
	ID         string
	Since      *time.Time
	Stderr     bool
	Stdout     bool
	Tail       string
	Timestamps bool
	Until      *time.Time
}

// NewLogsContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller logs action.
func NewLogsContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*LogsContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LogsContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramFollow := req.Params["follow"]
	if len(paramFollow) == 0 {
		rctx.Follow = false
	} else {
		rawFollow := paramFollow[0]
		if follow, err2 := strconv.ParseBool(rawFollow); err2 == nil {
			rctx.Follow = follow
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("follow", rawFollow, "boolean"))
		}
	}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	paramSince := req.Params["since"]
	if len(paramSince) > 0 {
		rawSince := paramSince[0]
		if since, err2 := time.Parse(time.RFC3339, rawSince); err2 == nil {
			tmp4 := &since
			rctx.Since = tmp4
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("since", rawSince, "datetime"))
		}
	}
	paramStderr := req.Params["stderr"]
	if len(paramStderr) == 0 {
		rctx.Stderr = false
	} else {
		rawStderr := paramStderr[0]
		if stderr, err2 := strconv.ParseBool(rawStderr); err2 == nil {
			rctx.Stderr = stderr
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("stderr", rawStderr, "boolean"))
		}
	}
	paramStdout := req.Params["stdout"]
	if len(paramStdout) == 0 {
		rctx.Stdout = false
	} else {
		rawStdout := paramStdout[0]
		if stdout, err2 := strconv.ParseBool(rawStdout); err2 == nil {
			rctx.Stdout = stdout
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("stdout", rawStdout, "boolean"))
		}
	}
	paramTail := req.Params["tail"]
	if len(paramTail) == 0 {
		rctx.Tail = "all"
	} else {
		rawTail := paramTail[0]
		rctx.Tail = rawTail
	}
	paramTimestamps := req.Params["timestamps"]
	if len(paramTimestamps) == 0 {
		rctx.Timestamps = false
	} else {
		rawTimestamps := paramTimestamps[0]
		if timestamps, err2 := strconv.ParseBool(rawTimestamps); err2 == nil {
			rctx.Timestamps = timestamps
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("timestamps", rawTimestamps, "boolean"))
		}
	}
	paramUntil := req.Params["until"]
	if len(paramUntil) > 0 {
		rawUntil := paramUntil[0]
		if until, err2 := time.Parse(time.RFC3339, rawUntil); err2 == nil {
			tmp8 := &until
			rctx.Until = tmp8
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("until", rawUntil, "datetime"))
		}
	}
	return &rctx, err
}

// NotFound sends a HTTP response with status code 404.
func (ctx *LogsContainerContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *LogsContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RemoveContainerContext provides the container remove action context.
type RemoveContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Force bool
	ID    string
}

// NewRemoveContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller remove action.
func NewRemoveContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*RemoveContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RemoveContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramForce := req.Params["force"]
	if len(paramForce) == 0 {
		rctx.Force = false
	} else {
		rawForce := paramForce[0]
		if force, err2 := strconv.ParseBool(rawForce); err2 == nil {
			rctx.Force = force
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("force", rawForce, "boolean"))
		}
	}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *RemoveContainerContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RemoveContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// RunningContainer sends a HTTP response with status code 409.
func (ctx *RemoveContainerContext) RunningContainer() error {
	ctx.ResponseData.WriteHeader(409)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RemoveContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// SetConfigContainerContext provides the container setConfig action context.
type SetConfigContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID      string
	Payload *ContainerConfig
}

// NewSetConfigContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller setConfig action.
func NewSetConfigContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*SetConfigContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SetConfigContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *SetConfigContainerContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// NotFound sends a HTTP response with status code 404.
func (ctx *SetConfigContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *SetConfigContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// StartContainerContext provides the container start action context.
type StartContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewStartContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller start action.
func NewStartContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*StartContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StartContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *StartContainerContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// NotFound sends a HTTP response with status code 404.
func (ctx *StartContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *StartContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// StopContainerContext provides the container stop action context.
type StopContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewStopContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller stop action.
func NewStopContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*StopContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StopContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *StopContainerContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// NotFound sends a HTTP response with status code 404.
func (ctx *StopContainerContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *StopContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// UploadContainerContext provides the container upload action context.
type UploadContainerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID      string
	Payload *UploadPayload
}

// NewUploadContainerContext parses the incoming request URL and body, performs validations and creates the
// context used by the container controller upload action.
func NewUploadContainerContext(ctx context.Context, r *http.Request, service *goa.Service) (*UploadContainerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UploadContainerContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *UploadContainerContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UploadContainerContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UploadContainerContext) NotFound(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 404, r)
}

// RequestEntityTooLarge sends a HTTP response with status code 413.
func (ctx *UploadContainerContext) RequestEntityTooLarge() error {
	ctx.ResponseData.WriteHeader(413)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *UploadContainerContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// AddAuthorizedKeysUserContext provides the user addAuthorizedKeys action context.
type AddAuthorizedKeysUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *UserAuthorizedKey
}

// NewAddAuthorizedKeysUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller addAuthorizedKeys action.
func NewAddAuthorizedKeysUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*AddAuthorizedKeysUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AddAuthorizedKeysUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *AddAuthorizedKeysUserContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *AddAuthorizedKeysUserContext) BadRequest() error {
	ctx.ResponseData.WriteHeader(400)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AddAuthorizedKeysUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetConfigUserContext provides the user getConfig action context.
type GetConfigUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetConfigUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller getConfig action.
func NewGetConfigUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetConfigUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetConfigUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetConfigUserContext) OK(r *GoaUserConfig) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "vpn.application/goa.user.config+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetConfigUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GetDefaultShellUserContext provides the user getDefaultShell action context.
type GetDefaultShellUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetDefaultShellUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller getDefaultShell action.
func NewGetDefaultShellUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetDefaultShellUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetDefaultShellUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetDefaultShellUserContext) OK(r *GoaUserDefaultshell) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "vpn.application/goa.user.defaultshell+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *GetDefaultShellUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// ListAuthorizedKeysUserContext provides the user listAuthorizedKeys action context.
type ListAuthorizedKeysUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewListAuthorizedKeysUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller listAuthorizedKeys action.
func NewListAuthorizedKeysUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListAuthorizedKeysUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListAuthorizedKeysUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListAuthorizedKeysUserContext) OK(r GoaUserAuthorizedkeyCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "vpn.application/goa.user.authorizedkey+json; type=collection")
	}
	if r == nil {
		r = GoaUserAuthorizedkeyCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListAuthorizedKeysUserContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ListAuthorizedKeysUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// RemoveAuthorizedKeysUserContext provides the user removeAuthorizedKeys action context.
type RemoveAuthorizedKeysUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Label string
}

// NewRemoveAuthorizedKeysUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller removeAuthorizedKeys action.
func NewRemoveAuthorizedKeysUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*RemoveAuthorizedKeysUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RemoveAuthorizedKeysUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramLabel := req.Params["label"]
	if len(paramLabel) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("label"))
	} else {
		rawLabel := paramLabel[0]
		rctx.Label = rawLabel
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *RemoveAuthorizedKeysUserContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RemoveAuthorizedKeysUserContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RemoveAuthorizedKeysUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// SetAuthorizedKeysUserContext provides the user setAuthorizedKeys action context.
type SetAuthorizedKeysUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload SetAuthorizedKeysUserPayload
}

// NewSetAuthorizedKeysUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller setAuthorizedKeys action.
func NewSetAuthorizedKeysUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*SetAuthorizedKeysUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SetAuthorizedKeysUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// SetAuthorizedKeysUserPayload is the user setAuthorizedKeys action payload.
type SetAuthorizedKeysUserPayload []*UserAuthorizedKey

// Validate runs the validation rules defined in the design.
func (payload SetAuthorizedKeysUserPayload) Validate() (err error) {
	for _, e := range payload {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// NoContent sends a HTTP response with status code 204.
func (ctx *SetAuthorizedKeysUserContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *SetAuthorizedKeysUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// SetDefaultShellUserContext provides the user setDefaultShell action context.
type SetDefaultShellUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	DefaultShell string
}

// NewSetDefaultShellUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller setDefaultShell action.
func NewSetDefaultShellUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*SetDefaultShellUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SetDefaultShellUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramDefaultShell := req.Params["defaultShell"]
	if len(paramDefaultShell) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("defaultShell"))
	} else {
		rawDefaultShell := paramDefaultShell[0]
		rctx.DefaultShell = rawDefaultShell
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *SetDefaultShellUserContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *SetDefaultShellUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}
