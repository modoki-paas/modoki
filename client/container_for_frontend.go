// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "Modoki API": containerForFrontend Resource Client
//
// Command:
// $ goagen
// --design=github.com/modoki-paas/modoki/design
// --out=$(GOPATH)/src/github.com/modoki-paas/modoki
// --version=v1.4.0

package client

import (
	"bytes"
	"context"
	"fmt"
	"golang.org/x/net/websocket"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"time"
)

// CreateContainerForFrontendPath computes a request path to the create action of containerForFrontend.
func CreateContainerForFrontendPath() string {

	return fmt.Sprintf("/frontend/v2/container/create")
}

// create a new container
func (c *Client) CreateContainerForFrontend(ctx context.Context, path string, image string, name string, command []string, entrypoint []string, env []string, sslRedirect *bool, volumes []string, workingDir *string) (*http.Response, error) {
	req, err := c.NewCreateContainerForFrontendRequest(ctx, path, image, name, command, entrypoint, env, sslRedirect, volumes, workingDir)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewCreateContainerForFrontendRequest create the request corresponding to the create action endpoint of the containerForFrontend resource.
func (c *Client) NewCreateContainerForFrontendRequest(ctx context.Context, path string, image string, name string, command []string, entrypoint []string, env []string, sslRedirect *bool, volumes []string, workingDir *string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	values.Set("image", image)
	values.Set("name", name)
	for _, p := range command {
		tmp73 := p
		values.Add("command", tmp73)
	}
	for _, p := range entrypoint {
		tmp74 := p
		values.Add("entrypoint", tmp74)
	}
	for _, p := range env {
		tmp75 := p
		values.Add("env", tmp75)
	}
	if sslRedirect != nil {
		tmp76 := strconv.FormatBool(*sslRedirect)
		values.Set("sslRedirect", tmp76)
	}
	for _, p := range volumes {
		tmp77 := p
		values.Add("volumes", tmp77)
	}
	if workingDir != nil {
		values.Set("workingDir", *workingDir)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// DownloadContainerForFrontendPath computes a request path to the download action of containerForFrontend.
func DownloadContainerForFrontendPath(id string) string {
	param0 := id

	return fmt.Sprintf("/frontend/v2/container/%s/download", param0)
}

// DownloadContainerForFrontendPath2 computes a request path to the download action of containerForFrontend.
func DownloadContainerForFrontendPath2() string {

	return fmt.Sprintf("/frontend/v2/container/download")
}

// Copy files from the container
func (c *Client) DownloadContainerForFrontend(ctx context.Context, path string, internalPath string) (*http.Response, error) {
	req, err := c.NewDownloadContainerForFrontendRequest(ctx, path, internalPath)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewDownloadContainerForFrontendRequest create the request corresponding to the download action endpoint of the containerForFrontend resource.
func (c *Client) NewDownloadContainerForFrontendRequest(ctx context.Context, path string, internalPath string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	values.Set("internalPath", internalPath)
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// ExecContainerForFrontendPath computes a request path to the exec action of containerForFrontend.
func ExecContainerForFrontendPath(id string) string {
	param0 := id

	return fmt.Sprintf("/frontend/v2/container/%s/exec", param0)
}

// Exec a command with attaching to a container using WebSocket(Mainly for xterm.js, using a protocol for terminado)
func (c *Client) ExecContainerForFrontend(ctx context.Context, path string, command []string, tty *bool) (*websocket.Conn, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "ws"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if command != nil {
		for _, p := range command {
			tmp78 := p
			values.Add("command", tmp78)
		}
	}
	if tty != nil {
		tmp79 := strconv.FormatBool(*tty)
		values.Set("tty", tmp79)
	}
	u.RawQuery = values.Encode()
	url_ := u.String()
	cfg, err := websocket.NewConfig(url_, url_)
	if err != nil {
		return nil, err
	}
	return websocket.DialConfig(cfg)
}

// GetConfigContainerForFrontendPath computes a request path to the getConfig action of containerForFrontend.
func GetConfigContainerForFrontendPath(id string) string {
	param0 := id

	return fmt.Sprintf("/frontend/v2/container/%s/config", param0)
}

// Get the config of a container
func (c *Client) GetConfigContainerForFrontend(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewGetConfigContainerForFrontendRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewGetConfigContainerForFrontendRequest create the request corresponding to the getConfig action endpoint of the containerForFrontend resource.
func (c *Client) NewGetConfigContainerForFrontendRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// InspectContainerForFrontendPath computes a request path to the inspect action of containerForFrontend.
func InspectContainerForFrontendPath(id string) string {
	param0 := id

	return fmt.Sprintf("/frontend/v2/container/%s/inspect", param0)
}

// Return details of a container
func (c *Client) InspectContainerForFrontend(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewInspectContainerForFrontendRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewInspectContainerForFrontendRequest create the request corresponding to the inspect action endpoint of the containerForFrontend resource.
func (c *Client) NewInspectContainerForFrontendRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// ListContainerForFrontendPath computes a request path to the list action of containerForFrontend.
func ListContainerForFrontendPath() string {

	return fmt.Sprintf("/frontend/v2/container/list")
}

// Return a list of containers
func (c *Client) ListContainerForFrontend(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewListContainerForFrontendRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewListContainerForFrontendRequest create the request corresponding to the list action endpoint of the containerForFrontend resource.
func (c *Client) NewListContainerForFrontendRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// LogsContainerForFrontendPath computes a request path to the logs action of containerForFrontend.
func LogsContainerForFrontendPath(id string) string {
	param0 := id

	return fmt.Sprintf("/frontend/v2/container/%s/logs", param0)
}

// Get stdout and stderr logs from a container.
func (c *Client) LogsContainerForFrontend(ctx context.Context, path string, follow *bool, since *time.Time, stderr *bool, stdout *bool, tail *string, timestamps *bool, until *time.Time) (*websocket.Conn, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "ws"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if follow != nil {
		tmp80 := strconv.FormatBool(*follow)
		values.Set("follow", tmp80)
	}
	if since != nil {
		tmp81 := since.Format(time.RFC3339)
		values.Set("since", tmp81)
	}
	if stderr != nil {
		tmp82 := strconv.FormatBool(*stderr)
		values.Set("stderr", tmp82)
	}
	if stdout != nil {
		tmp83 := strconv.FormatBool(*stdout)
		values.Set("stdout", tmp83)
	}
	if tail != nil {
		values.Set("tail", *tail)
	}
	if timestamps != nil {
		tmp84 := strconv.FormatBool(*timestamps)
		values.Set("timestamps", tmp84)
	}
	if until != nil {
		tmp85 := until.Format(time.RFC3339)
		values.Set("until", tmp85)
	}
	u.RawQuery = values.Encode()
	url_ := u.String()
	cfg, err := websocket.NewConfig(url_, url_)
	if err != nil {
		return nil, err
	}
	return websocket.DialConfig(cfg)
}

// RemoveContainerForFrontendPath computes a request path to the remove action of containerForFrontend.
func RemoveContainerForFrontendPath(id string) string {
	param0 := id

	return fmt.Sprintf("/frontend/v2/container/%s/remove", param0)
}

// remove a container
func (c *Client) RemoveContainerForFrontend(ctx context.Context, path string, force bool) (*http.Response, error) {
	req, err := c.NewRemoveContainerForFrontendRequest(ctx, path, force)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewRemoveContainerForFrontendRequest create the request corresponding to the remove action endpoint of the containerForFrontend resource.
func (c *Client) NewRemoveContainerForFrontendRequest(ctx context.Context, path string, force bool) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	tmp86 := strconv.FormatBool(force)
	values.Set("force", tmp86)
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// SetConfigContainerForFrontendPath computes a request path to the setConfig action of containerForFrontend.
func SetConfigContainerForFrontendPath(id string) string {
	param0 := id

	return fmt.Sprintf("/frontend/v2/container/%s/config", param0)
}

// Change the config of a container
func (c *Client) SetConfigContainerForFrontend(ctx context.Context, path string, payload *ContainerConfig, contentType string) (*http.Response, error) {
	req, err := c.NewSetConfigContainerForFrontendRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewSetConfigContainerForFrontendRequest create the request corresponding to the setConfig action endpoint of the containerForFrontend resource.
func (c *Client) NewSetConfigContainerForFrontendRequest(ctx context.Context, path string, payload *ContainerConfig, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// StartContainerForFrontendPath computes a request path to the start action of containerForFrontend.
func StartContainerForFrontendPath(id string) string {
	param0 := id

	return fmt.Sprintf("/frontend/v2/container/%s/start", param0)
}

// start a container
func (c *Client) StartContainerForFrontend(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewStartContainerForFrontendRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewStartContainerForFrontendRequest create the request corresponding to the start action endpoint of the containerForFrontend resource.
func (c *Client) NewStartContainerForFrontendRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// StopContainerForFrontendPath computes a request path to the stop action of containerForFrontend.
func StopContainerForFrontendPath(id string) string {
	param0 := id

	return fmt.Sprintf("/frontend/v2/container/%s/stop", param0)
}

// stop a container
func (c *Client) StopContainerForFrontend(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewStopContainerForFrontendRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewStopContainerForFrontendRequest create the request corresponding to the stop action endpoint of the containerForFrontend resource.
func (c *Client) NewStopContainerForFrontendRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// UploadContainerForFrontendPath computes a request path to the upload action of containerForFrontend.
func UploadContainerForFrontendPath(id string) string {
	param0 := id

	return fmt.Sprintf("/frontend/v2/container/%s/upload", param0)
}

// Copy files to the container
func (c *Client) UploadContainerForFrontend(ctx context.Context, path string, payload *UploadPayload, contentType string) (*http.Response, error) {
	req, err := c.NewUploadContainerForFrontendRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewUploadContainerForFrontendRequest create the request corresponding to the upload action endpoint of the containerForFrontend resource.
func (c *Client) NewUploadContainerForFrontendRequest(ctx context.Context, path string, payload *UploadPayload, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	w := multipart.NewWriter(&body)

	{
		fw, err := w.CreateFormField("allowOverwrite")
		if err != nil {
			return nil, err
		}
		tmp_AllowOverwrite := payload.AllowOverwrite
		s := strconv.FormatBool(tmp_AllowOverwrite)
		if _, err := fw.Write([]byte(s)); err != nil {
			return nil, err
		}
	}
	{
		fw, err := w.CreateFormField("copyUIDGID")
		if err != nil {
			return nil, err
		}
		tmp_CopyUIDGID := payload.CopyUIDGID
		s := strconv.FormatBool(tmp_CopyUIDGID)
		if _, err := fw.Write([]byte(s)); err != nil {
			return nil, err
		}
	}
	{
		_, file := filepath.Split(payload.Data)
		fw, err := w.CreateFormFile("data", file)
		if err != nil {
			return nil, err
		}
		fh, err := os.Open(payload.Data)
		if err != nil {
			return nil, err
		}
		defer fh.Close()
		if _, err := io.Copy(fw, fh); err != nil {
			return nil, err
		}
	}
	{
		fw, err := w.CreateFormField("path")
		if err != nil {
			return nil, err
		}
		tmp_Path := payload.Path
		s := tmp_Path
		if _, err := fw.Write([]byte(s)); err != nil {
			return nil, err
		}
	}
	if err := w.Close(); err != nil {
		return nil, err
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	header.Set("Content-Type", w.FormDataContentType())
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}
